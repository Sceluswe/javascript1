<!doctype html>
<html lang="sv">
<head>
<meta charset="utf-8">
<title>Redovisning av kursmoment i kursen javascript1</title>
<link rel="stylesheet" href="style/reset.css">
<link rel="stylesheet" href="style/style.css">
</head>

<body>
<header>
    <img src="img/title1.png" alt="No title">
</header>

<main>
    <nav class="navbar">
        <ul>
            <li><a href="me.html">Me</a></li>
            <li><a href="redovisning.html">Redovisning</a></li>
        </ul>
    </nav>

    <article>
    <h1>Redovisning</h1>
    <p>Av Emil Mattsson</p>

    <nav class="reviews">
        <ul>
			<li><h3>Innehåll:</h3></li>
            <li><a href="#kmom01">Kmom01</a></li>
            <li><a href="#kmom02">kmom02</a></li>
            <li><a href="#kmom03">kmom03</a></li>
            <li><a href="#kmom04">kmom04</a></li>
            <li><a href="#kmom05">kmom05</a></li>
            <li><a href="#kmom06">kmom06</a></li>
            <li><a href="#kmom07">kmom07</a></li>
        </ul>
    </nav>

    <section id="kmom01">
    <h2>Kmom01: Utvecklingsmiljö</h2>
    <h3>Vilken utvecklingsmiljö använder du?</h3>
    <p>OS är Windows 10 för det mesta och Debian ibland. På båda använder jag Atom som text editor och har JSLint installerat som paket. I Windows 10 använder jag Cygwin och webbläsare är Firefox med Firebug installerat. På Debian använder jag Opera som webbläsare men kollar även upp att det fungerar i Chrome samt Edge.</p>

    <h3>Är du bekant med HTML, CSS och JavaScript sedan tidigare?</h3>
    <p>Jag har bekantat mig med alla tre inom tidigare kurser och egna projekt. HTML och CSS har jag lärt mig i htmlphp kursen, phpmvc kursen, oophp kursen samt på egen hand. När det gäller Javascript har jag arbetat med Node.js, Ajax och jQuery tidigare. Det är bra paket som förenklar språket men det ska bli kul att få bättre koll på grunderna och grundkoncepten som till exempel prototyper.</p>

    <h3>Är du bekant med terminalen och Unix-kommandon sedan tidigare?</h3>
    <p>Unix-kommandon har jag vant mig vid efter att ha lekt lite med min Debian dator och samma gäller terminalen i Windows. Jag är inte någon mästare på det utan kan mest grunderna: kopiera, ta bort, rättigheter, pakethantering och installation. </p>

    <h3>Gick det bra med JSFiddle? Länka till din JSFiddle.</h3>
    <p>Det gick alldeles utmärkt att använda JSFiddle, det har jag gjort förut men det är först nu som jag skapat ett konto på deras hemsida. Det kändes bra att ha nu när vi kommer använda det i kursen. <a href="https://jsfiddle.net/Scelus/mk0myn8t/5/" target="_blank">JsFiddle</a></p>

    <h3>Gick det bra att komma i gång med kursmomentet, var det lagom, för litet, för stort?</h3>
    <p>Det var segt att komma igång. Jag känner mig alltid mindre motiverad till att arbeta när kursmomentet inte utmanar mig, men jag behöver vänja mig vid att göra saker som jag anser enkla. Detta moment var en bra övning i det. I övrigt kändes det som ett riktigt litet moment i jämförelse med den tidigare Python kursen, där vi direkt började koda intensivt med grunderna. Däremot kan jag tänka mig att det blir bekvämt med något lite lättare för oss programstudenter efter att vi avslutat Python och htmlphp projekten. Möjligen kan detta moment känts lätt på grund av att man blivit varm i kläderna under tidigare kurser.</p>

    <h2 class="innerTitle">Reflektion</h2>
    <h3>Erfarenheter och lärdomar</h3>
    <p>Jag kollade på videon med Douglas Crockford och repeterade grundern i Javascript, som till exempel ”variable hoisting” (att variabler ”flyttas” upp och kan defineras efter att de används). Crockfords historia om hur programmeringsspråken utvecklats var intressant. Det intressanta var att programmerare verkar ovilliga att välkomna förändring. Jag tycker vi borde vara extra öppna för det eftersom tekniken ständigt utvecklas och blir bättre. Personligen tror jag mig inte uppleva det problemet, allt förändras hela tiden och det gäller att följa utvecklingen.</p>

    <p>Det blev mycket att läsa igenom i detta moment men kurslitteraturen var riktigt bra och artiklarna desto bättre. Det mest lärprika inom dessa var överblicken av de olika demo moduler som finns tillgängliga på mozillas hemsida. Att man kan arbeta med canvas och SVG (scalable vector graphics) är jag redan bekant med, men video har jag bara hört nämnas och VR (virtual reality) samt WebGL är ingenting jag använt förut. Får jag tid kommer jag kolla på dessa. Transformations i CSS är jag också bekant med, de har jag arbetat med samtidigt som jag lekte i canvas. Vad ”web workers” är för något vet jag inte än heller. Javascript i sig är ett intressant språk då det gått in på att använda prototyper istället för rak objektorientering. Jag anser att det behöver utvecklas mera för att slippa bort några av dess skarpa kanter, något som boken ”Javascript: The Good Parts” försöker med.</p>

    <p>Eftersom jag är bekant med Javascript sedan innan gjorde jag extra uppgiften och la ned mest tid på att skapa en me-sida med en snygg design. Med hjälp av en webbsida som skapat en färgplockare som använder sig av färgteorin, att en kombination av en kall och en varm färg passar bra tillsammans, så blev mitt val av färger följande: vitt, lite gråare vitt, orange och blått. Detta var helt nya koncept som jag fick lära mig och teorin verkar stämma, mina färger passar bra ihop. Samtidigt använde jag mig av typografins så kallade magiska nummer. Detta hämtade jag ifrån en artikel om typografi och mitt magiska nummer blev 24 pixlar. Tanken är att man utgår ifrån detta nummer och använder det som utgångspunkt i sitt stylesheet vid beräkning  av storleken på headers, radavstånd, allt.</p>

    <p>Här är länken till webbsidan, den fungerar snabbare än Adobes egna hemsida som försöker med ett liknande koncept: <a href="https://www.sessions.edu/color-calculator/" target="_blank">Färgkalkylator</a></p>

    <h3>Problem och lösningar</h3>
    <p>Jag kunde inte riktigt placera min logo som jag ville, tanken var att den skulle ligga ovanpå själva innehållet. För att lösa det sätte jag först minus i marginalen på innehållet vilket verkade okej, men det blev rörigt att hålla reda på padding och marginaler för de element som befanns sig i headern och huvudinnehållet eftersom dessa kunde komma att flytta upp eller ned logon. Efter att jag tänkt en stund så delade jag upp min webbsida med följande tags istället: header, main och footer. Med dem kunde jag placera mitt innehåll precis som tänkt och det blev lätt att se vad som bestämde storleken på paddingen runt logon, runt headern i innehållet och hur headern och main kunde ligga nära varandra. Det krävdes fortfarande minus på huvudinnehållets marginal men numret blev mindre och koden tydligare. Inget annat element kunde längre flytta på logon.</p>

    <p>Ett mindre problem jag fick när jag skrev min CSS kod för webbsidan var att sidan ”hoppade” till när jag bytte emellan länkarna ”Me” och ”Redovisning”. Detta berodde på att scrollbaren fanns på redovisningssidan men inte på Me sidan. Jag löste det igenom att lägga till ”overflow-y: scroll;” i stilen på mitt html element. Då syns scrollbaren hela tiden och ”hoppandet” försvinner.</p>

    <h3>Resultat</h3>
    <p>Med grunderna i Javascript repeterade, och med en tydlig och välskriven kurslitteratur, känner jag mig redo att börja med nästa moment. Det blev dessutom en webbsida vars design jag gjort helt själv med Windows 10 liknande navigeringsknappar, två kompletterande färger och en minimalistisk design överlag. Min kunskap inom design är därmed utökad även om detta inte var fokusen för denna kurs.</p>
    </section>



    <section id="kmom02">
        <h2>Kmom02: Variabler och loopar</h2>

        <h3>Har du programmerat i JavaScript tidigare?</h3>
        <p>Jag har programmerat inom Javascript tidigare, då med Node.js och jQuery. Denna fråga är snarlik ”Är du bekant med HTML, CSS och JavaScript sedan tidigare?” i kmom01 men jag gör mitt bästa för att lägga till något nytt. Inom Javascript är jag bekant med grunderna och de vanliga datastrukturerna men jag har inte bemästrat Javascripts sätt att hantera objekt än.</p>

        <h3>Vad tycker du är det svåraste, mest utmanande i utveckling med HTML, CSS och JavaScript - så här långt?</h3>
        <p>HTML5 och CSS3 har jag arbetat med länge nu och även om det alltid finns mer att lära sig så har jag koll på grunderna och de mera avancerade funktionaliteterna. Det svåra i Javascript är att koda utan att skapa buggar eftersom man som nybörjare helt enkelt inte vet hur man borde/ska koda i Javascript. Lyckligtvis har vi verktyg som hjälper oss och personligen följer jag rekommendationerna på JSLint hemsidan.</p>

        <p>Rekommendationerna: http://www.jslint.com/help.html</p>

        <h3>Hur gick det att utföra respektive uppgift, vilken tog mest tid och vilken var mest lärorik?</h3>
        <p>Lab1 var en repetitionsuppgift av grunderna i programmering (loopar, if-satser och variabler). En annorlunda sak i jämförelse med Python nämner jag i ”Problem och lösningar”.</p>

        <p>Skapandet av flaggor bekantade mig med hur man skapar trianglar i CSS. Man färgar botten av div elementets border, gör högra och vänstra bordern transparent och så gör man en uppåt pekande triangel. För varje flagga ville jag ha det svårare. Först skapade jag Tysklands flagga och sedan kravet Sverige. Därefter gick jag in på trianglar och z-index i skapandet av Jamaicas flagga. Slutligen tog jag Sydafrikas flagga, eftersom den skulle kräva användning av alla tidigare flaggors tillvägagångssätt. Detta var den svåraste uppgiften då jag ville få flagornas olika former och färger i rätt proportioner. Mos introduktions video och google tog mig hela vägen.</p>

        <p>Den snabbaste uppgiften var baddien eftersom den var handledd (i stortsett). Den gav mig en insikt i hur Javascript tar fram storleken på webbläsarens fönster. Extrauppgiften löste jag med hjälp av window.innerHeight, window.innerWidth samt numret noll och en if-sats som kollar om den nya tänkta positionen är innanför ramen eller ej. Slutligen förbättrade jag baddies rörelse med CSS3 transition.</p>

        <h2 class="innerTitle">Reflektion</h2>
        <h3>Lärdomar och erfarenheter</h3>
        <p>Jag kollade på en föreläsningsvideo med John Resig som inte fanns med i kursmaterialet där han gick igenom de problem som även jag ser med Javascript. Ett är att utveckla till flera webbläsare. Det andra är att det i grunden finns många buggar som förstör för en, John Resig summerade det så här: </p>

        <p>”Vilken funktion ni än använder för att hämta något ifrån DOM, så räkna med att den har en bugg.” - John Resig</p>

        <p>Videon: https://www.youtube.com/watch?v=dgI52y27O_I</p>

        <h3>Problem och lösningar</h3>
        <p>I lab uppgiften där det gällde att runda av ett flyt tal döck det upp problem. När jag letade i Javascript referensen så kunde jag inte hitta någon inbyggd funktion och det närmaste jag kom rätt svar var Number((myNum).toFixed(2)); men den visade sig kunna ge fel om man försöker avrunda ett tal som innehåller decimal värdet 5 (till exempel ger 1.0005, 1 istället för 1.01). Lösningen blev att använda exponential notationer istället:</p>

        <p>Number(Math.round(1.005+'e2')+'e-2'); // 1.01 <br>
        Lösningen hittade jag här: http://www.jacklmoore.com/notes/rounding-in-javascript/</p>

        <h3>Resultat</h3>
        <p>Uppgiften var en enkel introduktion till Javascript. Den har ett bra upplägg och den kändes nästan för lätt i baddie-uppgiften. Hade jag haft mer tid skulle jag provat att koda den ifrån grunden men nu fick jag prioritera att möta deadline och hålla mig inom ramarna. </p>
        </section>

        <section id="kmom03">
        <h2>Kmom03: Funktioner</h2>
        <h3>Har du programmerat med funktioner tidigare, känns det lätt eller svårt?</h3>
        <p>Jag har programmerat med funktioner i C++, PHP, Python, Java och även Javascript, jag har koll på dem nu. Mina svagheter ligger inom rekursiva funktioner och ”high-order” funktioner (det sistnämnda hoppas jag lära mig mer om i denna kurs).</p>

        <h3>Vad tycker du om video som läromedel, tycker du att de tillför något som läromedel?</h3>
        <p>Absolut. Genom att se hur en erfaren programmerare löser problem kan man själv lära sig av dem och på så sätt spara tid igenom att kopiera deras tillvägagångssätt. Dessutom är det aldrig fel att ha andra sätt att inhämta informationen på. Om man tröttnat på att läsa kan man vända sig till videon istället.</p>

        <h3>Vad tyckte du om de olika uppgifterna? Hur tänkte du när du utförde dem? Var de svåra eller lätta?</h3>
        <p>Labben var en repetition av funktioner för mig. Jag saknade labbar med ”high-order” funktioner och callbacks eftersom dessa är en viktig del av Javascript.</p>

        <p>Uppgiften med flaggor blev lite svårare eftersom jag utmanade mig själv att skriva så lite kod som möjligt. För att uppnå detta tänkte jag igenom uppgiften och skapade funktioner av den kod som skulle förekomma flera gånger. Sammanlagt blev det fyra variabler med HTML kod (en för varje flagga) och 2 funktioner. Första funktionen skapar en EventListener på respektive flaggas hyperlänk element, och sedan anropas funktionen ”addHTML”. AddHTML tar ett id och HTML kod som argument. Id:et bestämmer i vilket HTML element som HTML koden ska placeras. Jag kunde gjort allt till en funktion, men då hade jag inte kunnat återanvända ”addHTML”. I framtiden kan jag utveckla den så att den hanterar klasser ungefär som jQuery.</p>

        <p>Baddie uppgiften påminde mig om att det krävs tålamod och rutin när man löser problem. Denna övning tog tid (trots att jag efteråt anser att den var lätt) på grund av stress och att jag drog förhastade slutsatser innan jag tydligt identifierat problemet. En av dessa förhastade slutsatser var när jag antog att min baddie inte hoppade i Chrorme för att Chrome inte hanterade setTimeout rätt. Problemet var däremot att jag glömt testa i Firefox efter att jag gjort en ändring.</p>

        <p>I alla uppgifter hade jag kurslitteraturen och Javascript referensen laddad och redo. Under varje moment ville jag träna mig att bli mer rutinerad inom problemlösning igenom att: Identifiera problemet, ta reda på om det finns en inbyggd lösning, om ja, använd den. Om nej, skapa en egen.</p>

        <h2 class="innerTitle">Reflektion</h2>
        <h3>Erfarenheter och lärdomar</h3>
        <p>Lärdomen i detta moment blir att buggar och fel i koden kan dra ut på tiden mer än nödvändigt om man inte tänker över situationen ordentligt. Detta är något jag ser Mos göra snabbt i de videor som följer med kursmaterialet, vilket inspirerar mig till att göra det snabbt men då kan förhastade slutsatser ske och jag tappar kvalité. Med erfarenhet, tålamod och rutin kommer effektivitet. Detta kan jag bli bättre på. </p>

        <h3>Problem och lösningar</h3>
        <p>Jag fick ett valideringsfel som sa att setTimeout inte var en funktion, trots att den finns med i standard biblioteket. Min lösning blev att slå upp den i Javascript referensen. Där hittade jag att funktionen är en del av window objektet och igenom att skriva window.setTimeout istället för bara setTimeout så försvann validerings problemet. JSHint vill helt enkelt att man är tydlig med vilka objekt funktionerna tillhör.</p>

        <h3>Resultat</h3>
        <p>Resultatet är jag riktigt nöjd med. Min favorit uppgift blev flaggorna. Denna tänkte jag igenom noggrant innan jag började koda och det ledde till en enkel strukturerad kod. Bäst av allt fick jag en funktion som kan vidareutvecklas och återanvändas i framtiden i simplare projekt som inte kräver hela jQuery ramverket.</p>
    </section>

    <section id="kmom04">
        <h2>Kmom04: Arrayer och objekt</h2>
        <h3>Hur kändes det att bekanta sig med begreppet array?</h3>
        <p>Arrayer har jag arbetat med förut och det kändes helt normalt för mig. Det är en datastruktur jag förstår väl men som fungerar lite annorlunda i Javascript. I jämförelse med Python fungerar den mer som en dictionary. I bakgrunden finns en hash istället för att man plockar en viss del av minnet och sätter undan det. Men utöver det ser de snarlika ut kodmässigt.</p>

        <h3>Hur kändes det att bekanta sig med begreppet objekt?</h3>
        <p>Det bästa med objekt i Javascript är hur enkelt man kan skapa dem igenom objekt literaler, det blir tydligt och enkelt. Jag ser dock ett problem: Att gömma undan variabler är inte lika lätt eftersom man hela tiden kan lägga till nya variabler och funktioner. För att lösa detta kolade jag i referensen och hittade jag funktionen Freeze. Den gör så att ingenting kan läggas till, ändras eller tas bort ifrån objektet. Om man använder Freeze blir det dessutom en så kallad ”shallow freeze”. Det betyder att variabler fortfarande går att ändra på igenom funktioner. Detta skapar den encapsulation som jag föredrar eftersom den förhindrar oväntade ändringar i den bakomliggande datan. Det går även att göra en deepFreeze där inte ens funktioner kan ändra på det som finns i objektet men då behöver man implementera en funktion som fryser alla objekt i objektet.</p>

        <h3>Hur gick det att utföra uppgifterna, vilken tog mest tid och vilken var mest lärorik?</h3>
        <p>Labarna var riktigt bra denna gång eftersom slut uppgifterna var mer utmanande. Dessa uppgifter fick mig att tänka till lite extra för att hitta en lösning. Min favorit var hur man kollar om en punkt finns inuti en form (en början till en enklare ”collision detection”). </p>

        <p>Uppgiften med flaggor gick fort att genomföra. Jag förstår att tanken var att lära sig mer om hur man bygger upp objekt med hjälp av kod man redan är bekant vid, men efter förra uppgiften kändes det överflödigt. Vi satte då in flaggorna i funktioner och min kod blev så kort att objekt endast skapade flera (möjligen onödiga) rader.</p>

        <p>Det som tog mest tid var baddie uppgiften. Jag hade problem med att få baddie att röra sig. Av någon anledning hoppade han mellan vänstra översta hörnet och högra översta hörnet. Problemet låg i hur klassen ”baddie-left” lades till. Samma problem uppstod i förra momentet, klassen ”baddie-right” som funktionen ”turnRight” försöker använda fanns helt enkelt inte. Min lösning blev att ändra i funktionerna så att de byter mellan CSS klasserna ”baddie” och ”baddie-left” istället. Ytterligare ett problem var när jag skulle flytta lådan. Den gick att flytta en gång och sedan tog det stop. Detta berodde på att jag satte platsen för lådan till current och inte gameArea[current]. På så sätt fick platsen positionen för en tile istället för ett tile nummer.</p>

        <h2 class="innerTitle">Reflektion</h2>
        <h3>Erfarenheter och lärdomar</h3>
        <p>Min tanke under hela momentet var att börja med att öppna de länkar som fanns till Javascript referensen och som handlade om Objekt samt arrayer. Med dessa bredvid mig gick allting lättare eftersom jag kunde hitta vilka built-ins som finns och kan lösa problemen. Det blev en bra övning i hur man slår upp saker och en effektiv lärdom inför framtiden.</p>

        <h3>Problem och lösningar</h3>
        <p>De problem som jag fastnade på var egentligen enkla och jag hade kunnat lösa dem snabbare om det inte var för att jag varit trött och haft huvudvärk. Det gällde dock att bita ihop och fortsätta kämpa. Att ha en nedskriven rutin för hur jag kan lösa problem hjälper till enormt när kroppen inte vill (eftersom den slipper minnas hur den ska göra). Det som hjälpte mig igenom problemen var Firebug och console.log.</p>

        <h3>Resultat</h3>
        <p>Jag är nöjd med resultatet även om det hade kunnat ta kortare tid. Det var däremot sömn och en paus som behövdes för att allting skulle lösa sig. Momentet bjöd på en intensiv genomgång av funktioner och objekt och jag känner att jag fått ordentlig koll på hur dessa  fungerar. Det ända som behövs nu är mer repetition för att lära in vilka funktioner som finns tillgängliga inom dem. </p>
    </section>

    <section id="kmom05">
    <h2>Kmom05: DOM och events</h2>
    <h3>Hur upplevde du labben, var något svårt eller utmanande?</h3>
    <p>Jag gjorde labben till en utmaning. För att enkelt lösa uppgifterna skapade jag min egna high-order funktion vid namn styleElem. Den är inspirerad av jQuery. Funktionen tar en sträng och en callable, samt rest argument. Strängen är antingen en CSS-klass eller ett id som styleElem använder för att hämta element ifrån dokumentet med hjälp av querySelectorAll. Den hämtar alla element som har klassen/id:et. Därefter kollar den om några rest argument skickats in i funktionen. Slutligen kallar den på callable med ett av de returnerade elementen tills den gjort det för alla element som returnerats av querySelectorAll. De eventuella rest argumenten används som parametrar till callable funktionen. För att styleElem skulle fungera i så många webbläsare som möjligt valde jag att använda argument objektet och inte spread syntaxen för att hantera multipla argument. Spread syntaxen är nyare och finns endast i ECMA6. </p>

    <h3>Beskriv vad du gjorde som sista uppgift i labben.</h3>
    <p>Jag valde att göra så att man kan dela cirklar och rutor i två igenom att trycka på Z. För att halvcirklarna inte ska bli förstörda när deras storlek ökar/minskar så ändrar jag borderRadius för halvcirklar när så sker.</p>

    <h3>Berätta hur du tänkte när du gjorde ditt flagg-memory. Gick det bra?</h3>
    <p>Min första tanke var att jag behöver något som kan randomisera element i en lista. Efter att ha kollat runt insåg jag att Javascript inte har någon shuffle-funktion inbyggd. Snabbt hittade jag Durstenfelds version av Fisher-Yates algoritmen med tidskomplexitet O(n).</p>

    <p>Därefter skapade jag ett objekt ”Element” som innehåller 5 attribut. TagName, namnet på huvudelementets tag, till exempel ”div”. Classes, en lista med alla elementets klasser. Id, elementets id. Content, text eller annan HTML-kod som elementet innehåller och slutligen parent, den förälder som elementet skapas under när man skriver ut det. För att skriva ut ett element med hjälp av alla attribut använder man funktionen Element.draw.</p>

    <p>Avslutningsvis deklarerade jag en lista som innehåller alla flaggor och kastar in den i min shuffle-funktion. Sedan skriver jag ut flaggorna och skapar ett nytt element; ”block”. Block tar flaggans position, skapas ovanpå flaggan och gömmer den. En click-eventListener läggs sedan till på block och en lista vid namn ”selected” håller reda på vilken flagga som vissas, samt flaggans tillhörande block. På så sätt kan jag gömma flaggan igen, igenom att ta bort CSS klassen ”hidden” ifrån block. Detta görs efter några sekunder, om spelaren valt 2 flaggor och de inte är av samma typ.</p>

    <h3>Vad anser du om Crockfords videor, har du tittat på dem?</h3>
    <p>Det har varit intressant att lära sig om hur Javascript kom till och hur det kommer att utvecklas i framtiden, samt vilka fallgropar språket innehåller. En sådan har jag stött på i detta moment: när man lägger till ett element inom ett annat element så måste det göras med createElement funktionen, annars får inte det nya elementet någon förälder.</p>

    <h2 class="innerTitle">Reflektion</h2>
    <h3>Erfarenheter och lärdomar</h3>
    <p>I detta moment sträckte jag på mig och fick lära mig om hur man skapar sin egen high-order funktion med hjälp av rest argument och spread syntax (eller argument objektet), som ser ut på följande sätt myfunction(parameter, ...variableName). Där … indikerar att alla argument som kommer efter ska hanteras som rest argument. </p>

    <h3>Problem och lösningar</h3>
    <p>Min första plan var att hålla mig till funktionell programmering. Den iden fick jag kasta åt sidan och göra en objektorienterad lösning. Under skapandets gång insåg jag att den blev mer flexibel (mindre rader kod) och lättförståelig.</p>

    <h3>Resultat</h3>
    <p>Kursmomentet gav mig en genomgång i Javascripts mest grundläggande element och det hjälpte mig även att förstå hur jQuery fungerar i bakgrunden. jQuery har jag arbetat med förut men jag har alltid varit intresserad av att förstå grunden i det. Det var mycket kodande i momentet och det kändes ett tag som om det var för mycket men när jag väl tagit mig igenom allting så har jag fått bättre koll på språket än någonsin.</p>
    </section>

    <section id="kmom06">
    <h2>Kmom06: Modul och closure</h2>
	<h3>Har du några erfarenheter av design mönster sedan tidigare?</h3>
    <p>Tidigare har jag arbetat med design mönster inom C++, design mönster och objekt-orientering är jag därmed van vid. Fabriks mönstret inspirerade mig i detta moment till att skapa funktioner som returnerar färdiga HTML-objekt (noder).</p>
	
	<h3>Var det svårt att greppa hur function scope och closure fungerar eller känns det naturligt?</h3>
    <p>Funktion scope: inget annat kommer åt varibelerna i en funktion om man inte returnerar dem. Det ända onaturliga för mig var att en funktion som deklarerats innan en variabel fortfarande kan komma åt den. </p>
	<p>Closures: deklarera funktioner och variabler i en funktion för att utnyttja dess function scope till att gömma undan (enkapsulera) data, och endast tillgängliggöra det som behövs utanför funktionen. Detta görs igenom att referera till datan i det vi returnerar.</p>
	
	<h3>Kan du jämföra “module pattern” med någon annan liknande datastruktur?</h3>
    <p>Modul mönstret påminner om classer i C++, men det blir mindre kod och mindre filer eftersom man inte delar upp det hela i en header (översiktlig bild av klassens innehåll) och en cpp fil (deklarationer). Det blir mindre tydligt vad som är publikt eller privat och mindre översiktligt eftersom allt ligger i en ända lång fil.</p>
	
	<h3>Känns “module pattern som en bra kodstruktur”?</h3>
    <p>Modul mönstret är en bra kodstruktur i större program, där tillåts man separera kod och ge varje modul ett eget ansvarsområde. Det har fördelarna att koden blir enklare att felsöka och att ändra eftersom varje modul kan testas individuellt. I små program kan moduler ta mera tid att skapa och kräva flera rader kod än funktionell programmering, det lärde jag mig av föregående kursmoment.</p>
	
	<h3>Var boken “Learning JavaScript Design Patterns” lättläst eller lite för svår?</h3>
    <p>Boken var lättläst och matnyttig, men det hade varit lärorikt att gräva djupare och röra vid fler än ett design mönster. Design mönster verkar vara lösningar på vanligt förekommande problem, att studera dem är likvärt med att studera äldre programmerares erfarenheter, ”vad passar bäst under följande omständigheter?”, till exempel. Målet blir att lära mig när de passar och när andra inte gör det. Design mönster känns som steget efter grundläggande programmerings kunskaper.</p>
	
	<h2 class="innerTitle">Reflektion</h2>
	<h3>Erfarenheter och lärdomar</h3>
    <p>Jag lärde mig använda Array.prototype.indexOf. En funktion som kollar om ett angivet värde finns med i en array. Med den kunde jag skapa ett register över vilka knappar som blivit tryckta, utan att kopior döck upp. Dessutom hjälpte den mig att kolla om en bokstav fanns med i det rätta ordet.</p>
	<p>I javascript kan man helt undvika att använda sig av en gameloop (en while-loop som hela tiden kör programmet). Istället används event hanterare som aktiverar en händelse när användaren faktiskt gör något.</p>
	<p>Jag lät modulen Game skapa hela användargränssnittet igenom att använda HTML element i index.js, modulen hittar rätt element med hjälp av dess klass. Här kunde jag gjort det möjligt för användaren att själv namnge HTML elementen, istället för att hålla sig till en strikt HTML struktur. </p>
	<p>Game innehöll dessutom samtliga knappar samt skapandet av dem. En modulär lösning hade varit att koda en ”Knapp” modul som hanterar knapparna var för sig. Jag försökte, men kom inte på ett bra sätt att skapa eventhanterarna och därför fick de ingå i Game den här gången. Så här i efterhand tänker jag mig att Game kunde skapat evenhanteraren för varje knapp med hjälp av en funktion i ”Knapp” som tar en callback. På så sätt kunde vilka moduler som helst och vad som helst skett vid ett knapptryck, utan att man behöver ändra något i ”Knapp” modulen. Modulen kunde själv hållit ett register över vilka knappar som använts och sett till att ingen knapp kan användas två gånger. Detta blir en lärdom att ta med sig in i framtiden.</p>
	<p>På forumet och i chatten lärde jag mig att det snabbaste sättet att skapa ett element är att använda sig av förälder elementets innerHTML. Däremot får inte elementen som skapas föräldern som förälder. På det sättet kan man inte hitta föräldern igenom barnet (child.parentNode). Detta ser jag som ett potentiellt problem och valde därför att använda parent.appendChild funktionen istället.</p>
	
	<h3>Problem och lösningar</h3>
    <p>Jag insåg att en funktion som skapar och returnerar ett HTML-element reducerar antalet rader kod. Funktionens första parameter är en sträng med HTML-tagens typ. Andra parametern är ett objekt med fyra attribut: id (en sträng), classList (en array, alla index läggs till som klasser), text (innerHTML innehållet) och attrs. Attrs är ett objekt innehållande de HTML attribut som tagen behöver. Namnet på objektets attribut blir namnet på HTML attributet och värdet på objektets attribut blir värdet på HTML attributet.</p>
<p>Exempel:</p>
<pre>
var rightLane = createElem(”div”);
var googleLink = createElem(”a”, {
	id: ”leftLane”,
	classList: [”green”, ”left”],
	text: ”Hello World”,
	attrs: {href: ”www.google.com”}
});
</pre>
	<h3>Resultat</h3>
    <p>Resultatet blev mer återanvändbar kod, ett fungerande Hangman spel och design mönster som verktyg till framtiden. Min kunskap inom Javascript förbättrades igenom skapandet av createElem, då jag tog reda på hur man använder attributnamnen i ett objekt och undviker att använda förälder objektets attribut (Object.keys(obj) istället för en for loop). Det är jag nöjd med.</p>
    </section>

    <section id="kmom07">
        <h2>Kmom10: Projekt och examination</h2>
        <p>Först redogör jag för tre moduler som utgör grunden till projektet.</p>
        <h3>Elemu modulen</h3>
        <p>Denna modul återanvänds flera gånger i koden och den innehåller ett antal funktioner som förenklar mitt arbete.Till att börja med finns en shuffle funktion. Shuffle ändrar slumpmässigt om alla element i en array. Sedan finns en select, create och en remove funktion.</p>
        <p>Select funktionen tillåter mig att välja ett element i DOM:en med hjälp av dess klass eller id. Detta är en high-order funktion. Den tar 2 parametrar varav en är en callback funktion. Sedan hämtar den rätt nod ifrån DOM:en med hjälp av id/class och skickar in resultatet (noden eller noderna) som parameterar till callback funktionen. I mitt fall har den två parametrar och den andra är strängen som identifierar DOM elementet. Exempel på en sådan sträng är ”.content”. </p>
<pre>
window.Elemu.select(”.content”, function (node) {// kod som manipulerar ”node”});
</pre>
        <p>Create funktionen tillåter en att skapa en DOM nod med hjälp av en sträng och ett objekt. Strängen innehåller DOM nodens typ och objektet innehåller attribut var namn och innehåll används. Funktionen kan användas så här: </p>
<pre>
window.Elemu.create(”div”, {id: ”mydiv”, classList: [”myclass”], text: ”My content”};
</pre>
        <p>Remove funktionen är den enklaste. Den tar ett DOM objekt som parameter och tar bort det ifrån DOM:en. Exempel:</p>
<pre>
window.Elemu.remove(myNode);
</pre>
        <h3>Test.js modulen</h3>
        <p>Test.js modulen sparar varje deltest i en array och håller reda på det aktiva deltestet med hjälp av en nummer variabel. Test.js består huvudsakligen av tre funktioner. En init funktion, en start funktion och reset en funktion.</p>
        <p>Init funktionen initierar varje deltest med nödvändig data. Frågetesterna är gjorda så att man enkelt kan lägga till flera frågor om man behöver. </p>
        <p>Start funktionen körs i när sidan laddas och den kallar på start funktionen som finns i varje deltest. I denna funktion skickar den in klassnamnet ”.content”. Detta gör så att deltesterna skriver till "div" tagen med klassen ”content”. Dessutom tilldelar Test.js varje deltest en callback funktion som kommer att köras när deltestet är slut. Därefter startar den det första testet.</p>
        <p>Varje callback skapar och visar en knapp för användaren. När man trycker på knappen rensas innehållet i hemsidan och därefter startas nästa test i Test.js array. Jag undviker scope problem i samtliga callbacks igenom att använda ”that, this” idiomet. Man skapar alltså en variabel vid namn ”that” som innehåller ”this” i samma scope som man skapar callback funktionen. På så sätt hänvisar callbacken alltid rätt.</p>
        <p>Reset funktionen kan användas för att starta om ett deltest ifrån början. För att använda den skriver man ”Test.reset();” i konsolen oavsett vilket deltest man står på.</p>
        <h3>Question.js modulen</h3>
        <p>Question.js innehåller all data som en fråga kan tänkas behöva: en fråga, X antal svarsalternativ, ett korrekt svar, en variabel som håller reda på vad spelaren svarat och de DOM noder som visar upp frågan och svarsalternativen i webbläsaren. Frågan, svaren och det rätta svaret kan initieras utifrån med hjälp av en init funktion.</p>
        <p>Modulen skapar frågan som ett "p" element och varje svarsalternativ som ett knapp element, en "button". Sedan omsluts de i en wrapper "div". Denna wrapper kan skrivas ut i DOM:en och returneras ifrån funktionen getWrapper().</p>
        <p>Man kan kolla om användaren svarade rätt igenom funktionen getUserAnswer(). Den returnerar ”True” om rätt, ”False” om fel.</p>
        <p>Varje svarsalternativ består av en knapp som får en eventlyssnare. Den väntar på användarens input. Om man trycker på ett svarsalternativ registrerar frågeobjektet om det var rätt eller ej och sedan körs en callback funktion. Callback funktionen skickas in utifrån (av deltestet) igenom funktionen ”setCallback()”. Om ingen callback angetts körs en tom funktion. </p>
        <p>Slutligen innehåller Question.js en reset funktion som återställer datan och DOM elementen till sitt initierade stadie.</p>
        <h3>Deltest 1: Tipsfrågor</h3>
        <p>Denna uppgift löstes med hjälp av 3 moduler: Elemu.js, Question.js och Questions.js. Det är tidigare nämnda funktioner i Elemu.js som återanvänds här.</p>
        <p>Questions.js, fungerar som själva frågeställningstestet. 5 frågor skapas utifrån, i Test.js, igenom Questions.js funktion: ”createQuestion()”. CreateQuestion sparar ett initerat frågeobjekt (Question.js objekt) i Questions.js array och håller även reda på spelarens poäng.</p>
        <p>När man kallar på start() visas den första frågan och svar inväntas. När en fråga besvarats kollar Question.js med frågeobjektet om användaren svarat rätt.  Samtidigt visas vad det rätta svaret var i grön text och med grön markering på det rätta svarets knapp. Om användaren svarade fel visas det felaktiga svaret med hjälp av en röd markering på svarsknappen. Varje rätt svar ger 3 poäng, fel svar ger 0. Questions.js sparar summan av alla svar.</p>
        <p>Start() tar två parametrar. En sträng med ett klassnamn eller ett id till den DOM node som testet kommer att skrivas ut i. Den andra parametern är en callback. Denna callback kallas när testet är över och visar då upp en knapp som tillåter användaren att gå till nästa deltest. Deltestet är över när det inte finns flera frågor att besvara. Om det finns fler frågor att besvara används istället Question.js egna callback. Den visar upp en knapp som tar användaren till nästa fråga. </p>
        <p>Reset() startar om testet ifrån första frågan igen. Den använder sig av Question.js reset funktion för att starta om frågorna. Test.js använder sig av Questions.js reset funktion för att starta om hela testet. Därför funkar det att skriva ”Test.reset()” i konsolen för att börja om.</p>
        <h3>Deltest 2: Fizzbuzz</h3>
        <p>Fizzbuzz.js fungerar på liknande sätt som Questions.js. Den använder Question.js som grund för sin fråga. När Test.js kallar Fizzbuzz.js start funktion så genereras ett frågeobjekt med en Fizzbuzz sekvens och det sista numret i den sekvensen blir det nummer som spelaren ska lista ut. Frågeobjektet sparas i Fizzbuzz.js för att man enkelt ska kunna starta om testet. </p>
        <p>Därefter presenteras användaren med sekvensen och 4 alternativ om vad följande nummer kan vara: ett nummer, Fizz, Buzz eller Fizzbuzz. Som i föregående moment visas rätt svar i grön text och med grön bakgrund på rätt knapp. Svarar användaren fel visas det felaktiga svaret med röd bakgrund på knappen.</p>
        <p>När spelaren svarar på frågan tilldelas 3 poäng för rätt svar och 0 poäng för fel svar. Oavsett rätt eller fel så körs en callback som skickats in som parameter i Fizzbuzz.start(). Denna callback visar en knapp som tillåter spelaren att avsluta testet och gå vidare till nästa.</p>
        <p>Fizzbuzz.reset() funktion använder sig av frågeobjektets reset funktion samtidigt som den nollställer antalet insamlade poäng. Test.js använder sig av Fizzbuzz.reset() och därför funkar ”Test.reset()” i konsolen även här.</p>
        <h3>Deltest 3: Minne</h3>
        <p>Detta deltest löstes med modulerna memory.js, flag.js och Elemu.js. Flag.js innehåller flaggans namn och själva DOM noden.</p>
        <p>Hur detta deltest fungerar förklaras i en välkomstsida innan deltestets början. När spelaren vill börja testet kan denne trycka på en knapp. Välkomstsidan skrivs ut när Fizzbuzz.js testet är klart och Fizzbuzz.js modulen anropar den callback funktion som Test.js gav den.</p>
        <p>Memory.js skapar flagobjekt med hjälp av flag.js modulen. Därefter skapas två olika listor som skrivs ut i webbläsaren. Båda listorna innehåller de 9 olika flaggorna. En har endast namn, den andra har den grafiska flaggan. Listornas ordning ändras om med hjälp av Elemu.js shuffle funktion (den som jag redogjorde för tidigare) i början på testet. </p>
        <p>Den första listan som innehåller flaggnamnen får det första elementet förtydligat med tjock text och en pil som pekar emot det. Denna lista indikerar vilken flagga som spelaren ska trycka på och i vilken ordning. Om spelaren trycker på fel flagga så avslutas testet. </p>
        <p>Den andra listan med de grafiska flaggorna döljs efter 5 sekunder med hjälp av "div" element med ljus bakgrund och ett frågetecken. Dessa element har en eventListener som kollar om den flagga användaren valt stämmer överens med den flaggan som indikeras i den första listan. Om spelaren svarat rätt får den fortsätta gissa, gissar spelaren fel avslutas testet.</p>
        <p>I konsolen kan man skriva ”Test.reset();” för att börja om ifrån början. De två listorna ändras då inte om med ”shuffle” utan förblir densamma som när testet började för första gången.</p>
        <h2 class="innerTitle">Reflektion</h2>
        <h3>Erfarenhet och lärdomar</h3>
        <p>Projektet har tillåtit mig att förstärka mina kunskaper inom programmering och hur man kan bygga upp en mindre applikation på ett objektorienterat vis även i Javascript.  Det var min tanke att försöka bygga projektet ungefär som man bygger ett program i C++. Det höll inte ända vägen fram då en while loop som hela tiden kör i webbläsaren går segt. Istället fick jag tänka om och göra så att allting fungerade steg för steg med hjälp av callbacks och events.</p>
        <h3>Problem och lösningar</h3>
        <p>Jag fick problem med scopet men löste detta igenom att använda ”that-this” idiomet. Annat än detta uppstod det inga nämnvärda problem.</p>
        <h3>Resultat</h3>
        <p>Resultatet är jag inte helt nöjd med då det tog lång tid för mig att få det klart. Bättre planering och riskhantering hade hjälpt mig att hålla tiden. Jag nöjde mig med att endast göra grunden av samma anledning: tiden. Dessutom snöade jag in mig på cenceptet om callbacks och kanske hade det funnits ett enklare sätt att utföra detta på. Att förstå hur programmet skulle fungera med callbacks istället för en while-loop var det svåra. Det blev många callbacks vilket gjorde att det blev krångligt att hålla reda på scopen och flödet av applikationen, men jag kom inte på en bättre lösning. Det blev lättare att arbeta med dessa efter att jag dokumenterat hur de fungerade i en flow chart. På så sätt kunde jag hålla reda på konceptet även emellan arbetspassen. Det var lätta var att återanvända den kod som jag utvecklat under kursens gång.</p>
        <p>Projektet kändes rimligt och hjälpte en att lägga ihop alla ens kunskaper ifrån tidigare moment till en ända applikation. Kursen i stort har lärt mig hur jag kan använda javascript och vad som skiljer det ifrån andra språk (för det mesta high-order funktioner och callbacks), därför skulle jag rekommendera den till de jag känner.</p>
        <p>Lärarna och handledningen är som vanligt utmärkt. Det är hos mig själv det brustit i tid och planering. Kursen i sig är jag helt nöjd med och jag kan inte tänka mig några förbättringsförslag.</p>
    </section>
    </article>
</main>

<footer>
    <p>Emil Mattsson, emmd12</p>
</footer>

<script type="text/javascript" src="js/main.js"></script>
</body>
</html>
